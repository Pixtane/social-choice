\documentclass[11pt]{article}
\usepackage{amsmath, amssymb}
\usepackage{mathtools}
\usepackage[margin=1in]{geometry}
\usepackage[hidelinks,hypertexnames=false]{hyperref}

\title{Mathematics of Heterogeneous Distance Metrics}
\author{}
\date{}

\begin{document}
\maketitle

\section{Simulator}
\label{sec:simulator}

This section describes the simulator as implemented in the codebase. All quantities and procedures discussed below correspond precisely to the computations performed: geometry sampling, heterogeneous distance perception, utility formation, ballot formation, voting rules, manipulation (optional), and evaluation metrics.

\section{Basic objects and indexing}
\label{sec:sim-objects}

Fix:
\begin{itemize}
  \item number of independent election instances (``profiles'') \(P \in \mathbb{N}\),
  \item number of voters \(N \in \mathbb{N}\),
  \item number of candidates \(M \in \mathbb{N}\), \(M \ge 2\),
  \item spatial dimension \(d \in \mathbb{N}\), \(d \ge 1\),
  \item geometry bounds \(p_{\min} < p_{\max}\) (defaults \(p_{\min}=0, p_{\max}=1\)),
  \item a random seed \(s\) (optional; if absent, NumPy generates a fresh seed),
  \item a numerical tolerance \(\varepsilon\) (stored in config but not used in ranking conversion).
\end{itemize}

Indices:
\[
  p \in \{1,\dots,P\},\quad
  v \in \{1,\dots,N\},\quad
  c \in \{1,\dots,M\},\quad
  k \in \{1,\dots,d\}.
\]

For each profile \(p\), the simulator samples:
\[
  x^{(p)}_v \in [p_{\min},p_{\max}]^d \quad\text{(voter positions)},\qquad
  y^{(p)}_c \in [p_{\min},p_{\max}]^d \quad\text{(candidate positions)}.
\]

Given positions, it computes:
\[
  D^{(p)}_{v,c} \in \mathbb{R}_{\ge 0}\quad\text{(distance)},\qquad
  u^{(p)}_{v,c} \in [0,1]\quad\text{(utility)},\qquad
  R^{(p)}_v \in \{0,\dots,M-1\}^M\quad\text{(ranking permutation)}.
\]
Here \(R^{(p)}_v[0]\) is voter \(v\)'s top-ranked candidate index, etc.

\section{Randomness and reproducibility}
\label{sec:sim-rng}

All sampling uses NumPy's \texttt{default\_rng}. When a seed \(s\) is provided, the same seed is used for:
\begin{itemize}
  \item geometry sampling (voter/candidate positions),
  \item voting-rule tie-breaking when enabled (see Section~\ref{sec:sim-ties}),
  \item manipulation selection and poll noise when manipulation is enabled.
\end{itemize}

\section{Spatial geometry generation}
\label{sec:sim-geometry}

The simulator supports the following \emph{implemented} geometry methods for each profile \(p\).

\subsection{Uniform hypercube (\texttt{uniform})}
\label{sec:geo-uniform}

Independently for all \(p,v,k\):
\[
  (x^{(p)}_v)_k \sim \mathrm{Unif}(p_{\min}, p_{\max}),
  \qquad
  (y^{(p)}_c)_k \sim \mathrm{Unif}(p_{\min}, p_{\max}).
\]

\subsection{Clustered (\texttt{clustered})}
\label{sec:geo-clustered}

Let \(\phi \in [0,1]\) be a dispersion parameter and let \(\sigma_0>0\) be the base cluster variance (code default \(\sigma_0=0.15\)).  Define:
\[
  \sigma_{\text{voter}} \coloneqq \phi \sqrt{d}\,\sigma_0,
  \qquad
  \sigma_{\text{cand}} \coloneqq \tfrac12\sigma_{\text{voter}}.
\]
For each profile \(p\), sample a cluster center \(m^{(p)} \in [p_{\min}+0.3\Delta,\,p_{\max}-0.3\Delta]^d\) where \(\Delta = p_{\max}-p_{\min}\), and then:
\[
  x^{(p)}_v \sim \mathcal{N}\!\left(m^{(p)}, \sigma_{\text{voter}}^2 I_d\right)\ \text{clipped coordinate-wise to }[p_{\min},p_{\max}],
\]
\[
  y^{(p)}_c \sim \mathcal{N}\!\left(m^{(p)}, \sigma_{\text{cand}}^2 I_d\right)\ \text{clipped coordinate-wise to }[p_{\min},p_{\max}].
\]

\subsection{Single-peaked 1D (\texttt{single\_peaked})}
\label{sec:geo-single-peaked}

This method \emph{forces} \(d=1\). Voters are uniform on \([p_{\min},p_{\max}]\). Candidates are placed deterministically at evenly spaced positions between \(p_{\min}+0.2\Delta\) and \(p_{\max}-0.2\Delta\):
\[
  y^{(p)}_c = \bigl(p_{\min}+0.2\Delta\bigr) + \frac{c-1}{M-1}\bigl(0.6\Delta\bigr),
  \qquad c=1,\dots,M.
\]

\subsection{Polarized (\texttt{polarized})}
\label{sec:geo-polarized}

Let \(\Delta=p_{\max}-p_{\min}\). Define three centers:
\[
  \ell = (p_{\min}+0.15\Delta)\mathbf{1}_d,\quad
  r = (p_{\max}-0.15\Delta)\mathbf{1}_d,\quad
  m = \tfrac12(p_{\min}+p_{\max})\mathbf{1}_d,
\]
and a common dispersion:
\[
  \sigma = 0.08\,\Delta\,\sqrt{d}.
\]
For each profile \(p\), sample faction sizes:
\[
  N_L = \left\lfloor N\,U_L\right\rfloor,\quad U_L \sim \mathrm{Unif}(0.35,0.50),
\]
\[
  N_R = \left\lfloor N\,U_R\right\rfloor,\quad U_R \sim \mathrm{Unif}(0.35,0.50),
\]
\[
  N_M = N - N_L - N_R.
\]
Then sample \(N_L\) voters from \(\mathcal{N}(\ell,\sigma^2 I_d)\), \(N_R\) voters from \(\mathcal{N}(r,\sigma^2 I_d)\), and \(N_M\) voters from \(\mathcal{N}(m,\sigma^2 I_d)\), each clipped to \([p_{\min},p_{\max}]^d\), and finally uniformly shuffle the voter order.

Candidates: if \(M\ge 3\), then
\[
  y^{(p)}_1 \sim \mathcal{N}(\ell,(\sigma/2)^2 I_d),\quad
  y^{(p)}_2 \sim \mathcal{N}(m,(\sigma/2)^2 I_d),\quad
  y^{(p)}_3 \sim \mathcal{N}(r,(\sigma/2)^2 I_d),
\]
each clipped to \([p_{\min},p_{\max}]^d\). Any candidates \(c\ge 4\) are uniform in the hypercube. If \(M<3\), all candidates are uniform.

\subsection{One-dimensional uniform (\texttt{1d})}
\label{sec:geo-1d}

This method forces \(d=1\). Voters and candidates are uniform on \([p_{\min},p_{\max}]\).

\subsection{Two-dimensional triangle (\texttt{2d})}
\label{sec:geo-2d}

This method forces \(d=2\). Voters are uniform on \([p_{\min},p_{\max}]^2\). If \(M\ge 3\), candidates \(1,2,3\) are placed deterministically at:
\[
  y^{(p)}_1 = \bigl(p_{\min}+0.2\Delta,\ p_{\min}+0.3\Delta\bigr),\quad
  y^{(p)}_2 = \bigl(p_{\max}-0.2\Delta,\ p_{\min}+0.3\Delta\bigr),\quad
  y^{(p)}_3 = \bigl(\tfrac12(p_{\min}+p_{\max}),\ p_{\max}-0.2\Delta\bigr),
\]
and any candidates \(c\ge 4\) are uniform. If \(M<3\), all candidates are uniform in \([p_{\min},p_{\max}]^2\).

\section{Distance metrics}
\label{sec:sim-distance}

Given a voter position \(x\in\mathbb{R}^d\) and candidate position \(y\in\mathbb{R}^d\), the simulator implements:
\begin{align*}
  d_{L2}(x,y)     & \coloneqq \|x-y\|_2,                                                                                            \\
  d_{L1}(x,y)     & \coloneqq \|x-y\|_1 = \sum_{k=1}^d |x_k-y_k|,                                                                   \\
  d_{\infty}(x,y) & \coloneqq \|x-y\|_{\infty} = \max_{k} |x_k-y_k|,                                                                \\
  d_{\cos}(x,y)   & \coloneqq 1 - \mathrm{clip}\!\left(\frac{\langle x,y\rangle}{(\|x\|_2+\delta)(\|y\|_2+\delta)},\ -1,\ 1\right),
\end{align*}
with a small constant \(\delta = 10^{-10}\) used to avoid division by zero, and \(\mathrm{clip}\) denoting truncation to \([-1,1]\).

\section{Heterogeneous distance perception}
\label{sec:sim-heterogeneity}

The \emph{heterogeneous distance} option assigns a metric \(\mu_v\) to each voter \(v\) as a function of that voter's spatial \emph{centrality}.  Distances are then computed using the assigned metric:
\[
  D^{(p)}_{v,c} \coloneqq d_{\mu^{(p)}_v}\!\left(x^{(p)}_v,\ y^{(p)}_c\right).
\]
When heterogeneous distance is disabled, a single metric \(\mu\) is used for all voters:
\[
  D^{(p)}_{v,c} \coloneqq d_{\mu}\!\left(x^{(p)}_v,\ y^{(p)}_c\right).
\]

\subsection{Centrality normalization}
\label{sec:sim-centrality}

Let the hypercube center be:
\[
  z \coloneqq \tfrac12(p_{\min}+p_{\max})\mathbf{1}_d,
\]
and let the maximum possible Euclidean distance from \(z\) to any corner be the half-diagonal:
\[
  L_{\max} \coloneqq \sqrt{d}\,\frac{p_{\max}-p_{\min}}{2}.
\]
The simulator defines each voter's centrality as normalized Euclidean distance to \(z\):
\[
  \mathrm{cent}(x) \coloneqq \mathrm{clip}\!\left(\frac{\|x-z\|_2}{L_{\max}},\ 0,\ 1\right).
\]
Note that this normalization is always Euclidean, even if the voter will later use a non-Euclidean metric for candidate evaluation.

\subsection{Strategy A: center--extreme (\texttt{center\_extreme})}
\label{sec:sim-center-extreme}

Parameters:
\begin{itemize}
  \item center metric \(\mu_{\text{center}}\) (default \(L2\)),
  \item extreme metric \(\mu_{\text{extreme}}\) (default cosine),
  \item threshold mode in \{\texttt{percentile}, \texttt{radius}\} (default \texttt{percentile}),
  \item threshold \(t\in[0,1]\) (default \(t=0.5\)).
\end{itemize}

\paragraph{Percentile mode.}
Let \(c_v \coloneqq \mathrm{cent}(x_v)\) be the normalized L2 centrality for each voter \(v=1,\dots,N\).
Let \(\sigma\) be a permutation of \(\{1,\dots,N\}\) that sorts voters by increasing centrality:
\[
  c_{\sigma(1)} \le c_{\sigma(2)} \le \cdots \le c_{\sigma(N)}.
\]
Define the center group size:
\[
  K \coloneqq \lfloor tN \rfloor.
\]
Then the closest \(K\) voters \(\{\sigma(1),\dots,\sigma(K)\}\) use \(\mu_{\text{center}}\) and the remaining voters use \(\mu_{\text{extreme}}\):
\[
  \mu_v \coloneqq
  \begin{cases}
    \mu_{\text{center}},  & v \in \{\sigma(1),\dots,\sigma(K)\}, \\
    \mu_{\text{extreme}}, & \text{otherwise}.
  \end{cases}
\]

\paragraph{Effective radius.}
For reporting, define the effective radius as the cutoff centrality:
\[
  r_{\mathrm{eff}} \coloneqq
  \begin{cases}
    0,             & K=0,    \\
    c_{\sigma(K)}, & K\ge 1.
  \end{cases}
\]

\paragraph{Radius mode.}
In radius mode, the threshold \(t\) is applied directly to normalized centrality:
\[
  \mu(x) \coloneqq
  \begin{cases}
    \mu_{\text{center}},  & \mathrm{cent}(x) \le t, \\
    \mu_{\text{extreme}}, & \mathrm{cent}(x) > t.
  \end{cases}
\]

\subsection{Strategy B: radial steps (\texttt{radial\_steps})}
\label{sec:sim-radial-steps}

Parameters:
\begin{itemize}
  \item an ordered list of metrics \((\mu_0,\dots,\mu_{K-1})\) from center outward (default \((L1,L2,L\_{\infty})\)),
  \item a boundary scaling mode in \{\texttt{linear}, \texttt{logarithmic}, \texttt{exponential}\},
  \item a positive scaling parameter \(b>0\) (default \(b=2\)).
\end{itemize}

The simulator precomputes \(K-1\) boundaries \(0<\beta_1<\cdots<\beta_{K-1}<1\).

\paragraph{Linear boundaries.}
With \(K\) metrics, define equally spaced internal cutpoints:
\[
  (\beta_1,\dots,\beta_{K-1}) \coloneqq \left(\frac{1}{K}, \frac{2}{K}, \dots, \frac{K-1}{K}\right).
\]

\paragraph{Logarithmic boundaries.}
Let \(\{\ell_i\}_{i=0}^{K}\) be \(K+1\) points logarithmically spaced between \(b^0=1\) and \(b^1=b\), i.e. \(\ell_i=b^{i/K}\). The code then normalizes these to \([0,1]\) via:
\[
  \tilde{\ell}_i \coloneqq \frac{\ell_i - 1}{b-1},
\]
and uses the internal points \(\beta_j = \tilde{\ell}_j\) for \(j=1,\dots,K-1\).

\paragraph{Exponential boundaries.}
Let \(t_i=i/K\) for \(i=0,\dots,K\). The code maps linearly spaced \(t_i\) through:
\[
  \tilde{e}_i \coloneqq \frac{b^{t_i}-1}{b-1},
\]
and uses \(\beta_j=\tilde{e}_j\) for \(j=1,\dots,K-1\).

\paragraph{Metric assignment.}
Given a voter position \(x\), compute \(c=\mathrm{cent}(x)\). The region index is:
\[
  r(c) \coloneqq \min\Bigl(\bigl|\{j \in \{1,\dots,K-1\} : \beta_j < c\}\bigr|,\ K-1\Bigr).
\]
This matches the code's \texttt{searchsorted} behavior with the default left side: if \(c=\beta_j\), then \(r(c)=j-1\), so boundaries are included in the \emph{inner} region.
Finally \(\mu(x)\coloneqq \mu_{r(c)}\).

\section{Utility formation}
\label{sec:sim-utility}

Given distances \(D^{(p)}_{v,c}\), the simulator implements the following utility functions:

\subsection{Gaussian utility (\texttt{gaussian})}
\label{sec:util-gaussian}

Let \(\sigma_{\text{fac}}>0\) be a configuration parameter (default \(\sigma_{\text{fac}}=0.5\)). Define:
\[
  \sigma \coloneqq \sigma_{\text{fac}}\sqrt{d}.
\]
Utilities are:
\[
  u^{(p)}_{v,c} \coloneqq \exp\!\left(-\frac{(D^{(p)}_{v,c})^2}{2\sigma^2}\right).
\]

\subsection{Quadratic utility (\texttt{quadratic})}
\label{sec:util-quadratic}

Let \(d_{\max}>0\) be a configured maximum distance. If \(d_{\max}\) is not provided, the code defaults to:
\[
  d_{\max} \coloneqq \sqrt{d},
\]
which corresponds to the Euclidean diameter of the unit hypercube \([0,1]^d\) and does \emph{not} automatically adjust if geometry bounds are changed.
Utilities are:
\[
  u^{(p)}_{v,c} \coloneqq \max\!\left(0,\ 1 - \left(\frac{D^{(p)}_{v,c}}{d_{\max}}\right)^2\right).
\]

\subsection{Linear utility with per-voter normalization (\texttt{linear})}
\label{sec:util-linear}

This is the most important case for heterogeneous distance studies because the normalization depends on each voter's (possibly heterogeneous) metric.

\paragraph{Opposite hypercube corner.}
For a voter position \(x\in[p_{\min},p_{\max}]^d\), define the ``opposite corner'' \(o(x)\in\{p_{\min},p_{\max}\}^d\) coordinate-wise:
\[
  o(x)_k \coloneqq
  \begin{cases}
    p_{\min}, & |x_k - p_{\min}| \ge |x_k - p_{\max}|, \\
    p_{\max}, & |x_k - p_{\min}| < |x_k - p_{\max}|.
  \end{cases}
\]
Ties (\(=\)) go to \(p_{\min}\) (this is exactly the code's \(\ge\) branch).

\paragraph{Per-voter maximum distance.}
Let \(\mu_v\) be the metric assigned to voter \(v\) (heterogeneous) or the global metric (homogeneous). Define:
\[
  d_{\max,v} \coloneqq d_{\mu_v}\!\bigl(x_v,\, o(x_v)\bigr).
\]
To avoid division by zero in degenerate cases, the code uses a ``safe'' denominator:
\[
  \tilde{d}_{\max,v} \coloneqq
  \begin{cases}
    d_{\max,v}, & d_{\max,v} > 10^{-12}, \\
    1,          & \text{otherwise}.
  \end{cases}
\]

\paragraph{Linear utility.}
Utilities are then:
\[
  u^{(p)}_{v,c} \coloneqq 1 - \frac{D^{(p)}_{v,c}}{\tilde{d}_{\max,v}},
\]
and finally clipped to \([0,1]\).

\subsection{Non-implemented options}
\label{sec:util-not-implemented}

The configuration enum lists additional utility types (e.g.\ \texttt{exponential}, \texttt{saturated}), but the executed implementation raises an error for any utility function other than \texttt{gaussian}, \texttt{quadratic}, or \texttt{linear}. This chapter therefore treats only the implemented functions above.

\section{From utilities to rankings}
\label{sec:sim-rankings}

For each profile \(p\) and voter \(v\), the simulator converts the utility vector \(\bigl(u^{(p)}_{v,1},\dots,u^{(p)}_{v,M}\bigr)\) into an ordinal ranking by sorting in descending utility:
\[
  R^{(p)}_v \coloneqq \mathrm{argsort}\bigl(-u^{(p)}_{v,\cdot}\bigr).
\]
No explicit \(\varepsilon\)-tie handling is applied; ties are broken by the underlying \texttt{argsort} ordering (which may be implementation-dependent).

\section{Voting rules}
\label{sec:sim-rules}

Each profile is evaluated under one or more voting rules. Rules partition into:
\begin{itemize}
  \item \textbf{Cardinal rules} consuming utilities \(u_{v,c}\),
  \item \textbf{Ordinal rules} consuming rankings \(R_v\).
\end{itemize}

\subsection{Tie-breaking conventions}
\label{sec:sim-ties}

Some rules call a common tie-breaker on a vector of candidate scores \(S \in \mathbb{R}^M\):
\[
  \mathrm{tiebreak}(S) \in \arg\max_{c} S_c.
\]
If \(|\arg\max S|=1\), the unique maximizer is selected. Otherwise:
\begin{itemize}
  \item \texttt{random}: pick uniformly at random among tied maxima using the simulator RNG,
  \item \texttt{lexicographic}: pick the smallest candidate index among ties,
  \item \texttt{none}: behaves identically to \texttt{lexicographic} in the current code.
\end{itemize}
Important: many rules use NumPy \(\arg\max/\arg\min\) internally without \(\mathrm{tiebreak}\); those ties resolve to the first index returned by NumPy.

\subsection{Cardinal rules}
\label{sec:rules-cardinal}

Below, utilities are \(u_{v,c}\) for \(v=1,\dots,N\), \(c=1,\dots,M\).

\paragraph{Utilitarian (\texttt{utilitarian}).}
Score each candidate by total utility:
\[
  S_c \coloneqq \sum_{v=1}^{N} u_{v,c},
  \qquad
  \hat{c} \coloneqq \mathrm{tiebreak}(S).
\]

\paragraph{Approval (\texttt{approval}).}
Let \(A_{v,c}\in\{0,1\}\) indicate whether voter \(v\) approves candidate \(c\). The code supports these approval policies:
\begin{itemize}
  \item \texttt{top\_k}: \(A_{v,c}=1\) iff \(c\) is among the \(k\) highest-utility candidates for voter \(v\),
  \item \texttt{threshold}: \(A_{v,c}=1\) iff \(u_{v,c} > \tau\),
  \item \texttt{mean}: \(A_{v,c}=1\) iff \(u_{v,c} > \frac{1}{M}\sum_{j=1}^{M} u_{v,j}\),
  \item \texttt{above\_average}: \(A_{v,c}=1\) iff \(u_{v,c} > \frac{1}{NM}\sum_{v,j} u_{v,j}\).
\end{itemize}
Candidate scores and winner:
\[
  S_c \coloneqq \sum_{v=1}^{N} A_{v,c},
  \qquad
  \hat{c} \coloneqq \mathrm{tiebreak}(S).
\]

\paragraph{Score / range voting (\texttt{score}).}
Let \(L\in\mathbb{N}\) be the configured maximum score (\texttt{score\_max}, default \(L=5\)). Each voter rescales their own utilities independently:
\[
  u^{\min}_v \coloneqq \min_c u_{v,c},\qquad
  u^{\max}_v \coloneqq \max_c u_{v,c},\qquad
  \rho_v \coloneqq u^{\max}_v - u^{\min}_v,
\]
with \(\rho_v\) replaced by \(1\) if \(\rho_v=0\).
Normalized utilities:
\[
  \tilde{u}_{v,c} \coloneqq \frac{u_{v,c}-u^{\min}_v}{\rho_v} \in [0,1].
\]
Ballots:
\[
  b_{v,c} \coloneqq
  \begin{cases}
    \mathrm{round}(L\,\tilde{u}_{v,c}), & \text{if granularity is integer},    \\
    L\,\tilde{u}_{v,c},                 & \text{if granularity is continuous}.
  \end{cases}
\]
Scores and winner:
\[
  S_c \coloneqq \sum_{v=1}^{N} b_{v,c},
  \qquad
  \hat{c} \coloneqq \mathrm{tiebreak}(S).
\]

\paragraph{STAR (\texttt{star}).}
First compute score totals \(S_c\) exactly as in \texttt{score}. Let the finalists be the two candidates with highest totals:
\[
  (a,b) \coloneqq \text{the first two indices in } \mathrm{argsort}(-S).
\]
Then perform an automatic runoff using the \emph{original utilities} (not the rounded score ballots):
\[
  V_a \coloneqq \left|\{v : u_{v,a} > u_{v,b}\}\right|,\qquad
  V_b \coloneqq \left|\{v : u_{v,b} > u_{v,a}\}\right|.
\]
If \(V_a > V_b\) select \(a\); if \(V_b > V_a\) select \(b\). If \(V_a=V_b\), select the finalist with greater (or equal) score total \(S\) (i.e.\ choose \(a\) if \(S_a \ge S_b\), else choose \(b\)).

\paragraph{Median utility (\texttt{median}).}
Compute per-candidate medians:
\[
  S_c \coloneqq \mathrm{median}\bigl(u_{1,c},\dots,u_{N,c}\bigr),
  \qquad
  \hat{c} \coloneqq \mathrm{tiebreak}(S).
\]

\paragraph{Quadratic voting (\texttt{quadratic}).}
The code applies a signed square root transform to utilities:
\[
  w_{v,c} \coloneqq \mathrm{sign}(u_{v,c})\,\sqrt{|u_{v,c}|},
  \qquad
  S_c \coloneqq \sum_{v=1}^{N} w_{v,c},
  \qquad
  \hat{c} \coloneqq \mathrm{tiebreak}(S).
\]
Note: when utilities are nonnegative (as in this simulator's implemented utility functions), this reduces to \(w_{v,c}=\sqrt{u_{v,c}}\).

\subsection{Ordinal rules}
\label{sec:rules-ordinal}

Below, \(R_v\) is voter \(v\)'s ranking permutation, with \(R_v[0]\) the top choice.

\paragraph{Plurality (\texttt{plurality}).}
First-choice counts:
\[
  S_c \coloneqq \left|\{v : R_v[0]=c\}\right|,
  \qquad
  \hat{c} \coloneqq \mathrm{tiebreak}(S).
\]

\paragraph{Anti-plurality / veto (\texttt{anti\_plurality}, \texttt{veto}).}
Last-place counts \(L_c \coloneqq |\{v : R_v[M-1]=c\}|\). The code sets scores \(S_c = -L_c\) and applies \(\mathrm{tiebreak}\).

\paragraph{Borda (\texttt{borda}).}
Assign points \(M-1, M-2, \dots, 0\) to ranks \(0,1,\dots,M-1\). Score:
\[
  S_c \coloneqq \sum_{v=1}^{N} \bigl(M-1-\mathrm{rank}_v(c)\bigr),
\]
where \(\mathrm{rank}_v(c)\) is the index \(r\) such that \(R_v[r]=c\). Winner: \(\hat{c}=\mathrm{tiebreak}(S)\).

\paragraph{IRV (\texttt{irv}).}
Maintain an active set \(A \subseteq \{0,\dots,M-1\}\), initially all candidates active. In each round:
\begin{itemize}
  \item each voter contributes one vote to their highest-ranked active candidate,
  \item if some candidate has strictly more than half of active votes, that candidate wins,
  \item otherwise eliminate the active candidate with the \emph{fewest} first-choice votes (ties resolve by smallest index via \(\arg\min\) behavior), remove it from \(A\), and repeat.
\end{itemize}
If no strict majority occurs, the last remaining active candidate wins.

\paragraph{Coombs (\texttt{coombs}).}
As in IRV, but elimination removes the active candidate with the \emph{most} last-place votes among active candidates (ties resolve by smallest index via \(\arg\max\)).

\paragraph{Condorcet winner test (\texttt{condorcet}).}
Compute pairwise margins (Section~\ref{sec:sim-pairwise}). A Condorcet winner is a candidate that beats every other candidate by positive margin. If none exists, the voting-rule engine returns winner index \(-1\).

\paragraph{Minimax (\texttt{minimax}).}
Compute pairwise margins \(m_{i,j}\). For each candidate \(c\), define its worst defeat as:
\[
  W_c \coloneqq \max_{j\ne c}(-m_{c,j}),
\]
and set score \(S_c \coloneqq -W_c\). Winner is \(\mathrm{tiebreak}(S)\).

\paragraph{Copeland (\texttt{copeland}).}
Let \(w_c = |\{j\ne c : m_{c,j}>0\}|\) and \(\ell_c = |\{j\ne c : m_{c,j}<0\}|\). Score \(S_c \coloneqq w_c-\ell_c\). Winner is \(\mathrm{tiebreak}(S)\).

\paragraph{Schulze / beatpath (\texttt{schulze}).}
Compute pairwise margins and initialize a ``strength'' matrix:
\[
  P_{i,j} \coloneqq \max(m_{i,j},0)\quad (i\ne j),\quad P_{i,i}=0.
\]
Then apply the Floyd--Warshall-style update:
\[
  P_{i,j} \leftarrow \max\!\bigl(P_{i,j},\ \min(P_{i,k},P_{k,j})\bigr)\quad\text{for all }k,i,j,\ i\ne j.
\]
Finally, the code counts for each \(i\) how many \(j\ne i\) satisfy \(P_{i,j} > P_{j,i}\), and selects the maximum by \(\mathrm{tiebreak}\).

\paragraph{Ranked pairs / Tideman (\texttt{ranked\_pairs}).}
Build the set of directed pair victories \((w,\ell)\) with a positive margin, each annotated by its margin value. Sort these victories by decreasing margin. Iteratively ``lock'' a victory unless it would create a directed cycle in the locked graph. The winner is the candidate with no incoming edge in the locked graph; if multiple, the code selects the smallest index by scanning from \(0\) upward.

\paragraph{Bucklin (\texttt{bucklin}).}
Initialize scores \(S_c=0\). For \(r=0,1,\dots,M-1\):
\begin{itemize}
  \item add 1 to each voter's candidate at rank \(r\),
  \item if \(\max_c S_c\) exceeds \(N/2\) (strictly), select \(\arg\max S\) (ties by smallest index).
\end{itemize}
If no majority ever occurs, select \(\mathrm{tiebreak}(S)\) after the final round.

\paragraph{Nanson (\texttt{nanson}).}
Iteratively compute Borda scores on the active set and eliminate all candidates with below-average Borda score among active candidates. If no candidate is eliminated in a round (all remaining have score \(\ge\) average), stop. Winner is the smallest index remaining active.

\paragraph{Baldwin (\texttt{baldwin}).}
Iteratively compute Borda scores on the active set and eliminate the single candidate with lowest Borda score (ties by smallest index). Winner is the last remaining active candidate (smallest index if a tie in active representation).

\paragraph{Kemeny--Young (\texttt{kemeny\_young}).}
If \(M>8\), the code falls back to the Schulze method. Otherwise it enumerates all permutations \(\pi\) of candidates and scores each permutation by the sum of pairwise margins consistent with \(\pi\):
\[
  K(\pi) \coloneqq \sum_{i<j} m_{\pi_i,\pi_j}.
\]
It selects a maximizer \(\pi^\star\) (first encountered in enumeration order among ties) and declares \(\pi^\star_0\) the winner.

\section{Strategic manipulation (optional)}
\label{sec:sim-manipulation}

Manipulation is optional. When enabled, the simulator selects a subset of voters as manipulators and then modifies either:
\begin{itemize}
  \item utilities (for \texttt{bullet} strategy under cardinal rules), and/or
  \item rankings (for ordinal-rule strategies \texttt{compromise}, \texttt{burial}, \texttt{pushover}, \texttt{optimal}).
\end{itemize}
When a rule is cardinal, the simulator passes manipulated \emph{utilities} into the voting rule; when a rule is ordinal, it passes manipulated \emph{rankings}.
Thus, in the implemented code, most ranking-only manipulation strategies do not affect cardinal rules.

\subsection{Manipulator fraction and truncation}
\label{sec:manip-fraction}

Let \(f \in [0,1]\) be the configured manipulator fraction. The number of manipulators is:
\[
  N_{\text{manip}} \coloneqq \left\lfloor fN \right\rfloor,
\]
clipped to \([0,N]\).

\subsection{Manipulator selection methods}
\label{sec:manip-selection}

The code supports:
\begin{itemize}
  \item \texttt{random}: uniform subset of size \(N_{\text{manip}}\) without replacement,
  \item \texttt{extremists}: pick voters with largest variance \(\mathrm{Var}_c(u_{v,c})\),
  \item \texttt{centrists}: pick voters minimizing \(\sum_c (u_{v,c}-\bar{u}_c)^2\) where \(\bar{u}_c=\frac1N\sum_v u_{v,c}\),
  \item \texttt{informed}: approximate expected winner by plurality on \(\mathrm{argsort}(-u)\) first choices; pick voters maximizing \(\max_c u_{v,c} - u_{v,c^\star}\).
\end{itemize}

\subsection{Poll information (for \texttt{polls} and \texttt{full} information levels)}
\label{sec:manip-polls}

The polling model uses first-choice counts \(C_c\) from sincere rankings.
\begin{itemize}
  \item \texttt{full}: vote shares are \(C_c/N\),
  \item \texttt{polls}: add Gaussian noise \(C_c + \eta_c\) with \(\eta_c \sim \mathcal{N}(0,\sigma^2)\), \(\sigma = \texttt{poll\_noise}\cdot N\); clamp at 0 and renormalize to shares.
\end{itemize}
The set of ``viable'' candidates is those with share \(>0.1\) (in \texttt{polls}) or count \(>0.1N\) (in \texttt{full}).

\subsection{Manipulation strategies}
\label{sec:manip-strategies}

\paragraph{Bullet (\texttt{bullet}).}
Only applied for cardinal rules. For each manipulating voter \(v\), let \(c_1 = R_v[0]\) be their sincere top choice. Set:
\[
  u'_{v,c} \coloneqq 0\ \ (c\ne c_1),\qquad
  u'_{v,c_1} \coloneqq u_{v,c_1}.
\]

\paragraph{Compromise (\texttt{compromise}).}
Only modifies rankings and only when poll info is available. If a manipulator's top choice is not viable, the code promotes the first viable candidate appearing in their ranking to first place and keeps the remaining candidates in their original relative order.

\paragraph{Burial (\texttt{burial}).}
Only modifies rankings and only when poll info is available. If the poll ``frontrunner'' is not the voter's top choice, move the frontrunner to last place.

\paragraph{Pushover (\texttt{pushover}).}
Only modifies rankings and only when poll info is available. Let the ``weakest'' candidate be the one with smallest poll vote share. If that candidate is not already first, the code inserts the weakest candidate into \emph{second} position (index 1) while keeping the voter's sincere top choice in first place.

\paragraph{Optimal (\texttt{optimal}).}
For \(M \le 5\), for each manipulator \(v\), the code enumerates all possible rankings \(\pi\) and selects the one that maximizes the manipulator's \emph{sincere} utility for the resulting winner under the chosen voting rule. Note that for \emph{cardinal} rules, the implementation only varies rankings while passing unchanged utilities into the rule, so the winner is unaffected by \(\pi\) and the ``optimal'' search is effectively vacuous. For \(M>5\), the code falls back to a compromise call without poll info (which returns without changing rankings, i.e.\ performs no change).

\section{Evaluation metrics}
\label{sec:sim-metrics}

Metrics are computed \emph{using sincere utilities and rankings}, even if manipulation is enabled, so that welfare comparisons are measured against the true underlying preferences.

\subsection{Social utility vector}
\label{sec:sim-social-utility}

Define per-candidate mean utility:
\[
  \bar{u}_c \coloneqq \frac{1}{N}\sum_{v=1}^{N} u_{v,c}.
\]
For a selected winner \(\hat{c}\), define:
\[
  U_{\text{win}} \coloneqq \bar{u}_{\hat{c}},\quad
  U_{\max} \coloneqq \max_c \bar{u}_c,\quad
  U_{\min} \coloneqq \min_c \bar{u}_c.
\]

\subsection{Voter Satisfaction Efficiency (VSE)}
\label{sec:sim-vse}

Let \(\Delta U = U_{\max}-U_{\min}\). If \(\Delta U > \varepsilon\), the code computes:
\[
  \mathrm{VSE} \coloneqq \frac{U_{\text{win}}-U_{\min}}{\Delta U}.
\]
Otherwise (all candidates essentially tied), it sets \(\mathrm{VSE}=1\).

\subsection{Regret}
\label{sec:sim-regret}

Regret is:
\[
  \mathrm{Regret} \coloneqq U_{\max}-U_{\text{win}},
\]
and a normalized regret ratio \(\mathrm{Regret}/\Delta U\) is computed when \(\Delta U>\varepsilon\), else 0.

\subsection{Winner rank by social utility}
\label{sec:sim-winner-rank}

Let \(\pi\) be candidates sorted by descending \(\bar{u}_c\) (via \(\mathrm{argsort}(-\bar{u})\)). The winner rank is the index \(r\) such that \(\pi_r=\hat{c}\). Ties follow \(\mathrm{argsort}\) ordering.

\subsection{Pairwise margins and Condorcet winner}
\label{sec:sim-pairwise}

From rankings \(R_v\), define pairwise margin matrix \(m\in\mathbb{Z}^{M\times M}\):
\[
  m_{i,j} \coloneqq |\{v: i \text{ is ranked above } j \text{ by } v\}| - |\{v: j \text{ is ranked above } i \text{ by } v\}|.
\]
A Condorcet winner exists if some \(c\) satisfies \(m_{c,j}>0\) for all \(j\ne c\).

\subsection{Cycle detection and classification}
\label{sec:sim-cycles}

For \(M=3\), the code declares a cycle iff no Condorcet winner exists. It classifies cycles as:
\begin{itemize}
  \item type 1 if \(0 \succ 1\), \(1 \succ 2\), and \(2 \succ 0\) by positive margins,
  \item type 2 if \(1 \succ 0\), \(0 \succ 2\), and \(2 \succ 1\) by positive margins.
\end{itemize}
For \(M>3\), the code constructs the directed graph of strict pairwise-majority edges \(\{i\to j: m_{i,j}>0\}\) and applies a DFS-like check for cyclic reachability (as implemented).

\section{Pipeline summary}
\label{sec:sim-pipeline}

For each profile \(p=1,\dots,P\):
\begin{enumerate}
  \item sample voter and candidate positions \(\{x^{(p)}_v\}, \{y^{(p)}_c\}\) according to the chosen geometry (Section~\ref{sec:sim-geometry});
  \item compute distances \(D^{(p)}_{v,c}\) either with one metric or with heterogeneous per-voter metrics (Sections~\ref{sec:sim-distance}--\ref{sec:sim-heterogeneity});
  \item compute utilities \(u^{(p)}_{v,c}\) from distances (Section~\ref{sec:sim-utility});
  \item compute rankings \(R^{(p)}_v\) by sorting utilities (Section~\ref{sec:sim-rankings});
  \item optionally apply manipulation to obtain manipulated ballots (Section~\ref{sec:sim-manipulation});
  \item apply a voting rule to select a winner \(\hat{c}^{(p)}\) (Section~\ref{sec:sim-rules});
  \item if the chosen rule returns ``no winner'' (only \texttt{condorcet} does so), the simulator falls back to the utilitarian winner \(\arg\max_c \bar{u}_c\);
  \item compute metrics (VSE, regret, Condorcet/cycle properties) using sincere utilities and rankings (Section~\ref{sec:sim-metrics}).
\end{enumerate}

\section{Research methodology implemented in the repository}
\label{sec:sim-methodology}

The repository contains two research harnesses (\texttt{heterogenity-simulator/} and \texttt{heterogeneity-research/}) that instantiate the simulator repeatedly to measure the effect of heterogeneous distance on outcomes. This section documents the \emph{executed methodology} of the main comprehensive suite (\texttt{heterogenity-simulator/research\_suite.py}); it is the procedure used to generate the large JSON result files in \texttt{heterogenity-simulator/results/}.

\subsection{Common experimental configuration}
\label{sec:method-common}

Unless explicitly varied by a phase, the research suite uses:
\begin{itemize}
  \item geometry: \texttt{uniform} in dimension \(d\) with bounds \(p_{\min}=-1\), \(p_{\max}=1\),
  \item utility: \texttt{linear} (Section~\ref{sec:util-linear}),
  \item voting rules: \(\{\texttt{plurality},\texttt{borda},\texttt{irv}\}\),
  \item number of candidates: \(M=5\),
  \item number of profiles: \(P=200\),
  \item random seed: \(s=42\).
\end{itemize}

\subsection{Heterogeneous vs.\ homogeneous baselines}
\label{sec:method-baselines}

The suite focuses on the \texttt{center\_extreme} heterogeneity strategy (Section~\ref{sec:sim-center-extreme}). For a specified ordered metric pair \((\mu_{\text{center}}, \mu_{\text{extreme}})\) and threshold \(t\), it runs:
\begin{itemize}
  \item a \textbf{heterogeneous} configuration with \(\mu(x)=\mu_{\text{center}}\) for \(\mathrm{cent}(x)\le t\) and \(\mu(x)=\mu_{\text{extreme}}\) otherwise,
  \item a \textbf{homogeneous center baseline} using the single metric \(\mu_{\text{center}}\),
  \item a \textbf{homogeneous extreme baseline} using the single metric \(\mu_{\text{extreme}}\).
\end{itemize}

For each voting rule, the suite records:
\begin{itemize}
  \item \textbf{VSE} and \textbf{cycle / Condorcet metrics} (Section~\ref{sec:sim-metrics}) for heterogeneous and baseline runs,
  \item \textbf{VSE differences} (heterogeneous minus baseline),
  \item \textbf{disagreement rate} between heterogeneous and baseline winners:
        \[
          \mathrm{Disagree} \coloneqq 100 \cdot \frac{1}{P}\sum_{p=1}^{P} \mathbf{1}\!\left[\hat{c}^{(p)}_{\text{het}} \ne \hat{c}^{(p)}_{\text{homo}}\right].
        \]
\end{itemize}

\subsection{Phases of the comprehensive suite}
\label{sec:method-phases}

The suite executes the following phases:
\begin{itemize}
  \item \textbf{Voter scaling}: vary \(N\in\{10,25,50,100,200,300,400,500\}\) with fixed \(d=2\), \(t=0.5\), and default metrics \((L2,\cos)\).
  \item \textbf{Threshold sweep}: vary \(t\) over 19 values \(t \in \{0.05,0.10,\dots,0.95\}\) with fixed \(N=100\), \(d=2\), metrics \((L2,\cos)\).
  \item \textbf{Dimensional scaling}: vary \(d\in\{1,2,3,4,5,7,10\}\) with fixed \(N=100\), \(t=0.5\), metrics \((L2,\cos)\).
  \item \textbf{Metric-pair interactions}: for the metric set \(\{L1,L2,\cos,L_{\infty}\}\), run all ordered pairs \((\mu_{\text{center}},\mu_{\text{extreme}})\) with \(\mu_{\text{center}}\ne\mu_{\text{extreme}}\) at fixed \(N=100\), \(d=2\), \(t=0.5\). The suite also runs the reversed direction \((\mu_{\text{extreme}},\mu_{\text{center}})\) and reports the absolute difference in disagreement rates as an \emph{asymmetry} measure.
  \item \textbf{Final verification}: repeats the metric-pair interaction experiment at \(N=500\) (same \(d,t,P\)) to assess stability at larger electorates.
\end{itemize}
\end{document}